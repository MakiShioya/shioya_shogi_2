<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>HTML将棋 完成版</title>
<style>

body {
  font-family: sans-serif;
  background: #f5f5dc;
  display: flex;
  flex-direction: column;   /* ← 縦並びに変更 */
  align-items: center;      /* ← 中央揃え */
  padding: 20px;
}

#game { display: flex; gap: 20px; }
#center { text-align: center; }
#status { font-weight: bold; margin-bottom: 5px; }
#checkStatus { color: red; font-weight: bold; margin-bottom: 10px; }
table { border-collapse: collapse; background: #deb887; }
td { width: 50px; height: 50px; border: 1px solid #333; text-align: center; vertical-align: middle; font-size: 24px; cursor: pointer; user-select: none; }
td.selected { background: yellow; }
td.move { background: #90ee90; }

/* 駒台の設定 */

.hand {
  width: 160px;
  height: 320px;
  border: 1px solid #333;
  display: flex;
  flex-direction: column;
  background-size: cover;
  background-repeat: no-repeat;
  background-position: center;
}

.hand.active {
  box-shadow: 0 0 15px 5px gold;
  border-color: gold;
}


/* 後手（上・左側） */
.white-hand {
  background-image: url("komiya_2p_komadai.png");
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
}

/* 先手（下・右側） */
.black-hand {
  background-image: url("komiya_1p_komadai.png");
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
}


.hand div {
  overflow-y: auto;
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  justify-items: center;
  align-content: start;   /* ← 上に詰める */
}

.hand h3 {
  margin: 0 0 5px 0;
  font-size: 14px;
  text-align: center;
  color: black;
  text-shadow:
    -1px -1px 0 white,
     1px -1px 0 white,
    -1px  1px 0 white,
     1px  1px 0 white;
}

.hand span {
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid #333;
  cursor: pointer;
  font-size: 18px;
  background: #f5deb3;
}

.hand span.selected { background: yellow; }
#controls { margin-top: 10px; text-align: center; }
button { padding: 6px 12px; font-size: 14px; cursor: pointer; }

#game {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 20px;
}

#kifu {
  width: 400px;        /* 横幅を固定 */
  height: 200px;       /* 高さを固定 */
  overflow-y: auto;    /* 中身が多ければスクロール */
  border: 1px solid #333;
  padding: 6px;
  background: #fff;
  margin-top: 10px;
  font-size: 14px;
}

.side {
  display: flex;

  flex-direction: column;
  justify-content: space-between;
  height: 500px;
}

.side.left {
  align-items: flex-end;
}

.side.right {
  align-items: flex-start;
}

.square-btn {   /* 投了と待ったボタン */
  width: 160px;
  height: 160px;
  font-size: 20px;
  font-weight: bold;
  border-radius: 10px;　　/* 丸み */
  cursor: pointer;
}

</style>
</head>

<body>
<div id="game">
  <!-- 左側（後手） -->
  <div class="side left">
    <div class="hand white-hand" id="whiteHandBox">
      <h3>後手の持ち駒</h3>
      <div id="whiteHand"></div>
    </div>
    <button id="undoBtn" class="square-btn" onclick="undoMove()">待った</button>
  </div>

  <!-- 中央 -->
  <div id="center">
    <div id="status"></div>
    <div id="checkStatus"></div>
    <table id="board"></table>

  </div>

  <!-- 右側（先手） -->
  <div class="side right">
    <button id="resignBtn" class="square-btn" onclick="resign()">投了</button>
    <div class="hand black-hand" id="blackHandBox">
      <h3>先手の持ち駒</h3>
      <div id="blackHand"></div>
    </div>
  </div>

</div>

<div id="kifu" style="margin-top: 10px; text-align: left;"></div>




<script>

let bgm;

window.addEventListener("load", () => {
  bgm = document.getElementById("bgm");
  playBGM();
});

function playBGM() {
  bgm.volume = 0.3;
  bgm.play().catch(() => {
    document.addEventListener("click", playBGM, { once: true });
  });
}

function stopBGM() {
  bgm.pause();
  bgm.currentTime = 0;
}

// ページ読み込み時に再生を試みる
window.onload = () => {
  playBGM();
};


// 着手音。成り音

let moveSound, promoteSound;

window.addEventListener("load", () => {
  bgm = document.getElementById("bgm");
  moveSound = document.getElementById("moveSound");
  promoteSound = document.getElementById("promoteSound");
  playBGM();
});


const board = document.getElementById("board");
const blackHandDiv = document.getElementById("blackHand");
const whiteHandDiv = document.getElementById("whiteHand");
const statusDiv = document.getElementById("status");
const checkStatusDiv = document.getElementById("checkStatus");
const resignBtn = document.getElementById("resignBtn");
resignBtn.addEventListener("click", resignGame);


const pieceName = {
  "P": "歩","L":"香","N":"桂","S":"銀","G":"金","B":"角","R":"飛","K":"玉",
  "+P":"と","+L":"成香","+N":"成桂","+S":"成銀","+B":"馬","+R":"龍"
};

let boardState = [
  ["l","n","s","g","k","g","s","n","l"],
  ["","r","","","","","","b",""],
  ["p","p","p","p","p","p","p","p","p"],
  ["","","","","","","","",""],
  ["","","","","","","","",""],
  ["","","","","","","","",""],
  ["P","P","P","P","P","P","P","P","P"],
  ["","B","","","","","","R",""],
  ["L","N","S","G","K","G","S","N","L"]
];

let hands = { black: [], white: [] };
let turn = "black";
let selected = null;
let legalMoves = [];
let history = [];
let positionHistory = {};
let gameOver = false;
let winner = null;
let moveCount = 0;
let repetitionHistory = {};
let kifu = [];
let lastMoveTo = null;




/* ========= 基本操作 ========= */

function deepCopyState() {
  return {
    board: boardState.map(r => r.slice()),
    hands: {
      black: hands.black.slice(),
      white: hands.white.slice()
    },
    turn: turn,
    moveCount: moveCount,
    kifu: kifu.slice(),
    positionHistory: JSON.parse(JSON.stringify(positionHistory)),
    repetitionHistory: JSON.parse(JSON.stringify(repetitionHistory)),
    lastMoveTo: lastMoveTo ? { ...lastMoveTo } : null
  };
}

function restoreState(state) {
  boardState = state.board.map(r => r.slice());
  hands.black = state.hands.black.slice();
  hands.white = state.hands.white.slice();
  turn = state.turn;
  selected = null;
  legalMoves = [];
}

function undoMove() {
  if (history.length === 0 || gameOver) return;

  const prev = history.pop();

  boardState = prev.board.map(r => r.slice());
  hands.black = prev.hands.black.slice();
  hands.white = prev.hands.white.slice();
  turn = prev.turn;
  moveCount = prev.moveCount;
  kifu = prev.kifu.slice();
  positionHistory = JSON.parse(JSON.stringify(prev.positionHistory));
  repetitionHistory = JSON.parse(JSON.stringify(prev.repetitionHistory));
  lastMoveTo = prev.lastMoveTo ? { ...prev.lastMoveTo } : null;

  gameOver = false;
  winner = null;
  statusDiv.textContent = "";
  checkStatusDiv.textContent = "";

  render();
  showKifu();
}

/* ========= 描画 ========= */

function render() {
  if (gameOver) {
    if (winner === "black") {
      statusDiv.textContent = "先手の勝ちです！";
    } else if (winner === "white") {
      statusDiv.textContent = "後手の勝ちです！";
    } else {
      statusDiv.textContent = "千日手です。引き分け。";
    }
    checkStatusDiv.textContent = "";
  } else {
    statusDiv.textContent =
      "現在の手番：" + (turn === "black" ? "先手" : "後手") +
      " / 手数：" + moveCount +
      (isKingInCheck(turn) ? "　王手！" : "");

    checkStatusDiv.textContent = "";
  }

  board.innerHTML = "";
  for (let y = 0; y < 9; y++) {
    const tr = document.createElement("tr");
    for (let x = 0; x < 9; x++) {
      const td = document.createElement("td");
      const piece = boardState[y][x];
      if (piece) {
        const isWhite = piece === piece.toLowerCase();
        const key = piece.startsWith("+") ? "+" + piece.replace("+","").toUpperCase() : piece.toUpperCase();
        td.textContent = pieceName[key];
        if (isWhite) td.style.transform = "rotate(180deg)";
      }
      if (selected && !selected.fromHand && selected.x === x && selected.y === y) td.classList.add("selected");
      if (legalMoves.some(m => m.x === x && m.y === y)) td.classList.add("move");
      td.onclick = () => onCellClick(x, y);
      tr.appendChild(td);
    }
    board.appendChild(tr);
  }
    renderHands();

  // 駒台の光り切り替え
  const blackBox = document.getElementById("blackHandBox");
  const whiteBox = document.getElementById("whiteHandBox");

  blackBox.classList.remove("active");
  whiteBox.classList.remove("active");

  if (!gameOver) {
    if (turn === "black") {
      blackBox.classList.add("active");
    } else {
      whiteBox.classList.add("active");
    }
  }
}


function renderHands() {
  const order = ["P", "L", "N", "S", "G", "B", "R"];
  hands.black.sort((a, b) => order.indexOf(a) - order.indexOf(b));
  hands.white.sort((a, b) => order.indexOf(a) - order.indexOf(b));

  blackHandDiv.innerHTML = "";
  whiteHandDiv.innerHTML = "";

  hands.black.forEach((p, i) => {
    const span = document.createElement("span");
    span.textContent = pieceName[p];
    if (selected && selected.fromHand && selected.player === "black" && selected.index === i) span.classList.add("selected");
    span.onclick = () => selectFromHand("black", i);
    blackHandDiv.appendChild(span);
  });

  hands.white.forEach((p, i) => {
    const span = document.createElement("span");
    span.textContent = pieceName[p];
    if (selected && selected.fromHand && selected.player === "white" && selected.index === i) span.classList.add("selected");
    span.onclick = () => selectFromHand("white", i);
    whiteHandDiv.appendChild(span);
  });
}

/* ========= 入力 ========= */

function onCellClick(x, y) {
  if (gameOver) return;

  if (!selected) {
    const piece = boardState[y][x];
    if (!piece) return;

    const isWhite = piece === piece.toLowerCase();
    if ((turn === "black" && isWhite) || (turn === "white" && !isWhite)) return;

    selected = { x, y, fromHand: false };
    legalMoves = getLegalMoves(x, y);
    render();
    return;
  }

  const sel = selected;

  if (legalMoves.some(m => m.x === x && m.y === y)) {
    movePieceWithSelected(sel, x, y);
  }

  selected = null;
  legalMoves = [];
  render();
}


function selectFromHand(player, index) {
  if (gameOver) return;

  if (turn !== player) return;
  selected = { fromHand: true, player, index };
  legalMoves = getLegalDrops(player, hands[player][index]);
  render();
}

function movePieceWithSelected(sel, x, y) {
  history.push(deepCopyState());

  const pieceBefore = sel.fromHand
    ? hands[sel.player][sel.index]
    : boardState[sel.y][sel.x];

  const boardBefore = boardState.map(r => r.slice());

  // 仮に棋譜を生成
  const moveNumber = kifu.length + 1;
  kifu.push("");  

  // さしたときの音
  moveSound.currentTime = 0;
  moveSound.volume = 0.3;
  moveSound.play();

  if (sel.fromHand) {
    const piece = hands[sel.player][sel.index];
    boardState[y][x] = sel.player === "black" ? piece : piece.toLowerCase();
    hands[sel.player].splice(sel.index, 1);
  } else {
    let piece = boardState[sel.y][sel.x];
    const target = boardState[y][x];

    if (target) {
      hands[turn].push(target.replace("+","").toUpperCase());
    }

    const isWhite = piece === piece.toLowerCase();
    const player = isWhite ? "white" : "black";
    const isPromoted = piece.includes("+");
    const base = piece.replace("+","").toUpperCase();

    if (!isPromoted &&
        canPromote(base) &&
        (isInPromotionZone(sel.y, player) || isInPromotionZone(y, player))) {

      const mustPromote =
        (base === "P" || base === "L") && (y === (player === "black" ? 0 : 8)) ||
        (base === "N") && (y === (player === "black" ? 0 : 8) || y === (player === "black" ? 1 : 7));
      if (mustPromote || confirm("成りますか？")) {
        piece = promote(piece.toUpperCase());
        if (player === "white") piece = piece.toLowerCase();
        sel.promoted = true;

        // 成ったときの音
        promoteSound.currentTime = 0;
        promoteSound.volume = 0.8;
        promoteSound.play();

      } else {
        sel.unpromoted = true;
      }
    }


    boardState[sel.y][sel.x] = "";
    boardState[y][x] = piece;
  }

  // 棋譜を最終版に更新（成・不成を反映）
  kifu[kifu.length - 1] = formatMove(sel, x, y, pieceBefore, boardBefore, moveNumber);
  lastMoveTo = { x, y };



  // 手番交代
  turn = turn === "black" ? "white" : "black";
  showKifu();

  // ★ ここから追加（500手引き分け）
  moveCount++;
  if (moveCount >= 500) {
    gameOver = true;
    winner = null;
    statusDiv.textContent = "500手に達したため、引き分けです。";
    showKifu();
    return;
  }
  // ★ ここまで追加

  // 詰み判定
  if (isKingInCheck(turn) && !hasAnyLegalMove(turn)) {
    gameOver = true;
    winner = turn === "black" ? "white" : "black";
    showKifu();
  }

  // 千日手 ＋ 連続王手の千日手 判定
  const key = getPositionKey();
  positionHistory[key] = (positionHistory[key] || 0) + 1;

  // 局面の王手履歴を記録
  recordRepetition();

  if (positionHistory[key] >= 4) {
    const records = repetitionHistory[key].slice(-4);

    const allCheck = records.every(r => r.isCheck);
    const sameSide = records.every(r => r.checkingSide === records[0].checkingSide);

    gameOver = true;
    if (allCheck && sameSide && records[0].checkingSide !== null) {
      winner = records[0].checkingSide === "black" ? "white" : "black";
      statusDiv.textContent = "連続王手の千日手です。王手をかけ続けた側の負けです。";
    } else {
      winner = null;
      statusDiv.textContent = "千日手です。引き分け。";
      showKifu();
    }
  }
}


/* ========= 成り ========= */

function isInPromotionZone(y, player) { return player === "black" ? y <= 2 : y >= 6; }
function canPromote(piece) { return ["P","L","N","S","B","R"].includes(piece); }
function promote(piece) { return piece.startsWith("+") ? piece : "+" + piece; }

/* ========= 王手判定 ========= */

function findKing(player) {
  const k = player === "black" ? "K" : "k";
  for (let y = 0; y < 9; y++)
    for (let x = 0; x < 9; x++)
      if (boardState[y][x] === k) return {x, y};
  return null;
}

function isKingInCheck(player) {
  const king = findKing(player);
  if (!king) return false;
  const opponent = player === "black" ? "white" : "black";

  for (let y = 0; y < 9; y++) {
    for (let x = 0; x < 9; x++) {
      const p = boardState[y][x];
      if (!p) continue;
      const isWhite = p === p.toLowerCase();
      if ((opponent === "white" && isWhite) || (opponent === "black" && !isWhite)) {
        const moves = getRawLegalMoves(x, y);
        if (moves.some(m => m.x === king.x && m.y === king.y)) return true;
      }
    }
  }
  return false;
}

/* ========= 駒の動き ========= */

function getRawLegalMoves(x, y) {
  const piece = boardState[y][x];
  const isWhite = piece === piece.toLowerCase();
  const player = isWhite ? "white" : "black";
  const dir = player === "black" ? -1 : 1;
  const base = piece.replace("+","").toUpperCase();
  const promoted = piece.startsWith("+");
  const moves = [];

  function add(nx, ny) {
    if (nx < 0 || nx > 8 || ny < 0 || ny > 8) return false;
    const target = boardState[ny][nx];
    if (target && (target === target.toLowerCase()) === isWhite) return false;
    moves.push({ x: nx, y: ny });
    return !target;
  }
  function slide(dx, dy) {
    let nx = x + dx, ny = y + dy;
    while (add(nx, ny)) {
      nx += dx;
      ny += dy;
    }
  }

  if (!promoted) {
    switch (base) {
      case "P": add(x, y + dir); break;
      case "L": slide(0, dir); break;
      case "N": add(x - 1, y + 2 * dir); add(x + 1, y + 2 * dir); break;
      case "S":
        add(x - 1, y + dir); add(x, y + dir); add(x + 1, y + dir);
        add(x - 1, y - dir); add(x + 1, y - dir); break;
      case "G":
        add(x - 1, y + dir); add(x, y + dir); add(x + 1, y + dir);
        add(x - 1, y); add(x + 1, y); add(x, y - dir); break;
      case "K":
        for (let dx = -1; dx <= 1; dx++)
          for (let dy = -1; dy <= 1; dy++)
            if (dx || dy) add(x + dx, y + dy);
        break;
      case "B": slide(1,1); slide(-1,1); slide(1,-1); slide(-1,-1); break;
      case "R": slide(1,0); slide(-1,0); slide(0,1); slide(0,-1); break;
    }
  } else {
    if (base === "B") {
      slide(1,1); slide(-1,1); slide(1,-1); slide(-1,-1);
      add(x-1,y); add(x+1,y); add(x,y-1); add(x,y+1);
    } else if (base === "R") {
      slide(1,0); slide(-1,0); slide(0,1); slide(0,-1);
      add(x-1,y-1); add(x+1,y-1); add(x-1,y+1); add(x+1,y+1);
    } else {
      add(x - 1, y + dir); add(x, y + dir); add(x + 1, y + dir);
      add(x - 1, y); add(x + 1, y); add(x, y - dir);
    }
  }
  return moves;
}

/* ========= 自玉が王手になる手の禁止 ========= */

function getLegalMoves(x, y) {
  const raw = getRawLegalMoves(x, y);
  const piece = boardState[y][x];
  const isWhite = piece === piece.toLowerCase();
  const player = isWhite ? "white" : "black";

  return raw.filter(m => {
    const fromPiece = boardState[y][x];
    const toPiece = boardState[m.y][m.x];

    // 盤面を一時的に変更
    boardState[m.y][m.x] = fromPiece;
    boardState[y][x] = "";

    const inCheck = isKingInCheck(player);

    // 元に戻す
    boardState[y][x] = fromPiece;
    boardState[m.y][m.x] = toPiece;

    return !inCheck;
  });
}


/* ========= 持ち駒打ち（自玉王手禁止・二歩禁止込み） ========= */

function getLegalDrops(player, piece) {
  const moves = [];
  for (let y = 0; y < 9; y++) {
    for (let x = 0; x < 9; x++) {
      if (boardState[y][x] !== "") continue;

      // 打てない段チェック
      if ((piece === "P" || piece === "L") &&
          y === (player === "black" ? 0 : 8)) continue;
      if (piece === "N" &&
          (y === (player === "black" ? 0 : 8) ||
           y === (player === "black" ? 1 : 7))) continue;

      // 二歩禁止
      if (piece === "P") {
        let nifu = false;
        for (let ty = 0; ty < 9; ty++) {
          const p = boardState[ty][x];
          if (p && p.toUpperCase() === "P" && !p.startsWith("+") &&
              ((p === p.toUpperCase()) === (player === "black"))) {
            nifu = true;
            break;
          }
        }
        if (nifu) continue;

        // ★ 打ち歩詰め禁止
        if (isPawnDropMate(x, y, player)) continue;
      }

      // 自玉王手禁止チェック
      const placed = player === "black" ? piece : piece.toLowerCase();
      boardState[y][x] = placed;
      const inCheck = isKingInCheck(player);
      boardState[y][x] = "";
      if (inCheck) continue;

      moves.push({ x, y });
    }
  }
  return moves;
}


/* ========= 新規関数 ========= */

function hasAnyLegalMove(player) {
  // 盤上の駒
  for (let y = 0; y < 9; y++) {
    for (let x = 0; x < 9; x++) {
      const p = boardState[y][x];
      if (!p) continue;
      const isWhite = p === p.toLowerCase();
      if ((player === "black" && !isWhite) || (player === "white" && isWhite)) {
        if (getLegalMoves(x, y).length > 0) return true;
      }
    }
  }
  // 持ち駒
  const hand = hands[player];
  for (let i = 0; i < hand.length; i++) {
    if (getLegalDrops(player, hand[i]).length > 0) return true;
  }
  return false;
}


/* ========= 新規関数2 ========= */

function isPawnDropMate(x, y, player) {
  // 歩を仮に打つ
  const piece = player === "black" ? "P" : "p";
  boardState[y][x] = piece;

  // 相手番にしてチェック
  const opponent = player === "black" ? "white" : "black";
  const inCheck = isKingInCheck(opponent);
  const hasMove = hasAnyLegalMove(opponent);

  // 元に戻す
  boardState[y][x] = "";

  // 王手かつ合法手なし → 打ち歩詰め
  return inCheck && !hasMove;
}


/* ========= 新規関数3 ========= */

function getPositionKey() {
  const boardKey = boardState.map(r => r.join("")).join("/");
  const blackHand = hands.black.slice().sort().join("");
  const whiteHand = hands.white.slice().sort().join("");
  return boardKey + "|" + blackHand + "|" + whiteHand + "|" + turn;
}


/* ========= 新規関数4 ========= */

function getRepetitionKey() {
  return getPositionKey();
}


function recordRepetition() {
  const key = getPositionKey();
  if (!repetitionHistory[key]) {
    repetitionHistory[key] = [];
  }

  // 今の局面で王手をかけている側を記録
  const isCheck = isKingInCheck(turn);
  const checkingSide = isCheck ? (turn === "black" ? "white" : "black") : null;

  repetitionHistory[key].push({
    isCheck,
    checkingSide
  });
}


/* ========= 新規関数5 ========= */

function resignGame() {
  if (gameOver) return;
  if (!confirm("投了しますか？")) return;

  gameOver = true;
  winner = turn === "black" ? "white" : "black";
  statusDiv.textContent = "投了により、" + (winner === "black" ? "先手" : "後手") + "の勝ちです。";
  checkStatusDiv.textContent = "";
  showKifu();
}


/* ========= 新規関数6 ========= */

function formatMove(sel, x, y, pieceBefore, boardBefore, moveNumber) {
  const files = ["９","８","７","６","５","４","３","２","１"];
  const ranks = ["一","二","三","四","五","六","七","八","九"];

  const toFile = files[x];
  const toRank = ranks[y];

  const isDrop = sel.fromHand;
  const fromX = sel.x;
  const fromY = sel.y;

  const isSameSquare = lastMoveTo && lastMoveTo.x === x && lastMoveTo.y === y;

  const base = pieceBefore.replace("+", "").toUpperCase();

  const pieceNames = {
    "P": "歩", "L": "香", "N": "桂", "S": "銀",
    "G": "金", "B": "角", "R": "飛", "K": "玉"
  };

  const mark = (moveNumber % 2 === 1) ? "▲" : "△";
  let move = `${moveNumber}手目：${mark}`;

  // 同
  if (isSameSquare) {
    move += "同";
  } else {
    move += toFile + toRank;
  }

  move += pieceNames[base];

  // 打
  if (isDrop) {
    move += "打";
    return move;
  }

  // ★ 分岐表記（移動前の盤面で判定）
  const others = findOtherSamePieceMoves(sel, x, y, boardBefore);
  if (others.length > 0) {
    move += getDisambiguation(sel, x, y, others);
  }

  // ★ 成・不成
  const player = pieceBefore === pieceBefore.toLowerCase() ? "white" : "black";
  const wasPromoted = pieceBefore.includes("+");

  if (!wasPromoted && canPromote(base) &&
      (isInPromotionZone(fromY, player) || isInPromotionZone(y, player))) {
    if (sel.promoted) {
      move += "成";
    } else if (sel.unpromoted) {
      move += "不成";
    }
  }

  return move;
}




function showKifu() {
  const kifuDiv = document.getElementById("kifu");
  kifuDiv.innerHTML = "<h3>棋譜</h3>" + kifu.join("<br>");
}


/* ========= 新規関数7 ========= */


function findOtherSamePieceMoves(sel, x, y, boardBefore) {
  const result = [];
  const piece = boardBefore[sel.y][sel.x];
  const base = piece.replace("+","").toUpperCase();
  const player = piece === piece.toLowerCase() ? "white" : "black";

  for (let yy = 0; yy < 9; yy++) {
    for (let xx = 0; xx < 9; xx++) {
      if (xx === sel.x && yy === sel.y) continue;
      const p = boardBefore[yy][xx];
      if (!p) continue;
      if (p.replace("+","").toUpperCase() !== base) continue;

      const isWhite = p === p.toLowerCase();
      if ((player === "black" && isWhite) || (player === "white" && !isWhite)) continue;

      const moves = getLegalMovesFromBoard(xx, yy, boardBefore);
      if (moves.some(m => m.x === x && m.y === y)) {
        result.push({ x: xx, y: yy });
      }
    }
  }

  return result;
}


/* ========= 補助関数 ========= */


function getLegalMovesFromBoard(x, y, board) {
  const piece = board[y][x];
  const isWhite = piece === piece.toLowerCase();
  const player = isWhite ? "white" : "black";
  const raw = getRawLegalMovesFromBoard(x, y, board);

  return raw.filter(m => {
    const fromPiece = board[y][x];
    const toPiece = board[m.y][m.x];

    board[m.y][m.x] = fromPiece;
    board[y][x] = "";

    const inCheck = isKingInCheckFromBoard(player, board);

    board[y][x] = fromPiece;
    board[m.y][m.x] = toPiece;

    return !inCheck;
  });
}



/* ========= 補助関数2 ========= */

function getRawLegalMovesFromBoard(x, y, board) {
  const piece = board[y][x];
  const isWhite = piece === piece.toLowerCase();
  const player = isWhite ? "white" : "black";
  const dir = player === "black" ? -1 : 1;
  const base = piece.replace("+","").toUpperCase();
  const promoted = piece.startsWith("+");
  const moves = [];

  function add(nx, ny) {
    if (nx < 0 || nx > 8 || ny < 0 || ny > 8) return false;
    const target = board[ny][nx];
    if (target && (target === target.toLowerCase()) === isWhite) return false;
    moves.push({ x: nx, y: ny });
    return !target;
  }
  function slide(dx, dy) {
    let nx = x + dx, ny = y + dy;
    while (add(nx, ny)) {
      nx += dx;
      ny += dy;
    }
  }

  if (!promoted) {
    switch (base) {
      case "P": add(x, y + dir); break;
      case "L": slide(0, dir); break;
      case "N": add(x - 1, y + 2 * dir); add(x + 1, y + 2 * dir); break;
      case "S":
        add(x - 1, y + dir); add(x, y + dir); add(x + 1, y + dir);
        add(x - 1, y - dir); add(x + 1, y - dir); break;
      case "G":
        add(x - 1, y + dir); add(x, y + dir); add(x + 1, y + dir);
        add(x - 1, y); add(x + 1, y); add(x, y - dir); break;
      case "K":
        for (let dx = -1; dx <= 1; dx++)
          for (let dy = -1; dy <= 1; dy++)
            if (dx || dy) add(x + dx, y + dy);
        break;
      case "B": slide(1,1); slide(-1,1); slide(1,-1); slide(-1,-1); break;
      case "R": slide(1,0); slide(-1,0); slide(0,1); slide(0,-1); break;
    }
  } else {
    if (base === "B") {
      slide(1,1); slide(-1,1); slide(1,-1); slide(-1,-1);
      add(x-1,y); add(x+1,y); add(x,y-1); add(x,y+1);
    } else if (base === "R") {
      slide(1,0); slide(-1,0); slide(0,1); slide(0,-1);
      add(x-1,y-1); add(x+1,y-1); add(x-1,y+1); add(x+1,y+1);
    } else {
      add(x - 1, y + dir); add(x, y + dir); add(x + 1, y + dir);
      add(x - 1, y); add(x + 1, y); add(x, y - dir);
    }
  }
  return moves;
}


/* ========= 補助関数3 ========= */


function isKingInCheckFromBoard(player, board) {
  const k = player === "black" ? "K" : "k";
  let king = null;

  for (let y = 0; y < 9; y++)
    for (let x = 0; x < 9; x++)
      if (board[y][x] === k) king = {x, y};

  if (!king) return false;

  const opponent = player === "black" ? "white" : "black";

  for (let y = 0; y < 9; y++) {
    for (let x = 0; x < 9; x++) {
      const p = board[y][x];
      if (!p) continue;
      const isWhite = p === p.toLowerCase();
      if ((opponent === "white" && isWhite) || (opponent === "black" && !isWhite)) {
        const moves = getRawLegalMovesFromBoard(x, y, board);
        if (moves.some(m => m.x === king.x && m.y === king.y)) return true;
      }
    }
  }
  return false;
}




/* ========= 新規関数8 ========= */

function getDisambiguation(sel, x, y, others) {
  const fromX = sel.x;
  const fromY = sel.y;

  const dx = x - fromX;
  const dy = y - fromY;

  const isForward = (dy < 0 && turn === "black") || (dy > 0 && turn === "white");
  const isBackward = !isForward;

  // 直（縦移動）
  if (dx === 0) {
    return "直";
  }

  // 右・左（先手視点）
  const isRight = (turn === "black" && dx < 0) || (turn === "white" && dx > 0);
  const isLeft  = !isRight;

  // 上・引・寄
  if (isForward) {
    return isRight ? "右上" : "左上";
  } else if (isBackward) {
    return isRight ? "右引" : "左引";
  } else {
    return isRight ? "右寄" : "左寄";
  }
}



/* ========= 新規 ========= */

positionHistory[getPositionKey()] = 1;

render();
showKifu();


</script>

<audio id="bgm" src="natsu2.mp3" loop></audio>
<audio id="moveSound" src="move.mp3"></audio>
<audio id="promoteSound" src="promote.mp3"></audio>



</body>
</html>
